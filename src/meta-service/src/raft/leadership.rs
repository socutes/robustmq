// Copyright 2023 RobustMQ Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{
    controller::{start_controller, stop_controller},
    core::cache::MetaCacheManager,
    raft::manager::{MultiRaftManager, RaftStateMachineName},
};
use node_call::NodeCallManager;
use std::{sync::Arc, time::Duration};
use tokio::{select, sync::broadcast, time::sleep};
use tracing::{error, info};

pub fn monitoring_leader_transition(
    cache_manager: Arc<MetaCacheManager>,
    raft_manager: Arc<MultiRaftManager>,
    call_manager: Arc<NodeCallManager>,
    stop_send: broadcast::Sender<bool>,
) {
    // Use the single metadata shard leader as the controller leadership source.
    let metadata_shard = format!("{}_0", RaftStateMachineName::METADATA.as_str());
    let metadata_node = raft_manager
        .metadata
        .get_node(&metadata_shard)
        .expect("metadata shard must exist");
    let mut metrics_rx = metadata_node.metrics();
    let mut controller_running = false;
    tokio::spawn(async move {
        let mut last_leader: Option<u64> = None;
        let mut stop_recv = stop_send.subscribe();
        let (controller_stop_recv, _) = broadcast::channel::<bool>(2);

        loop {
            select! {
            val = stop_recv.recv() => {
                if let Ok(flag) = val {
                    if flag {
                        break;
                    }
                }
            }

            val =  metrics_rx.changed() => {
                match val {
                    Ok(_) => {
                        let mm = metrics_rx.borrow().clone();
                        if let Some(current_leader) = mm.current_leader {
                            if last_leader != Some(current_leader)  {
                                if mm.id == current_leader{
                                    info!("[metadata] Leader transition has occurred. current leader is {:?}. previous leader was {:?}. local node id={}", current_leader, last_leader, mm.id);
                                    start_controller(
                                        &raft_manager,
                                        &cache_manager,
                                        &call_manager,
                                        controller_stop_recv.clone(),
                                    );
                                    controller_running = true;
                                } else if controller_running {
                                    stop_controller(controller_stop_recv.clone());
                                    controller_running = false
                                }

                                last_leader = Some(current_leader);
                            }
                        }
                    }

                    Err(changed_err) => {
                        error!("Error while watching metrics_rx: {}; quitting monitoring_leader_transition() loop",changed_err);}
                    }
                }
            }
        }
        sleep(Duration::from_secs(1)).await;
    });
}
